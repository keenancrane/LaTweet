<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaTweet!</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/default.min.css">
    
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 15px;
            line-height: 1.5;
            font-weight: 400;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
            color: #333;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Hide content during initial load - keep background visible */
        body:not(.loaded) .container {
            visibility: hidden;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: #667eea;
            color: white;
            padding: 20px 30px;
        }
        
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .header-text {
            text-align: center;
            flex: 1;
        }
        
        .header .theme-toggle {
            flex-shrink: 0;
            margin-top: 10px;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2em;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        
        .header p {
            margin: 5px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
            font-weight: 400;
        }
        
        .copy-all-btn {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 6px 10px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        
        .copy-all-btn:hover {
            background: #f8f9fa;
            color: #2ed573;
            border-color: #2ed573;
            transform: translateY(-1px);
        }
        
        .copy-all-btn svg {
            transition: all 0.2s ease;
        }
        
        .copy-all-btn:hover svg {
            transform: scale(1.1);
        }
        
        .controls {
            padding: 20px 30px;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .platform-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .platform-selector label {
            font-weight: 500;
            color: #666;
            font-size: 14px;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .checkbox-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }
        
        .checkbox-text {
            font-size: 13px;
            font-weight: 500;
            color: #666;
            text-align: center;
        }
        
        .platform-selector select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 400;
            color: #333;
        }
        
        .platform-selector select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .theme-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            font-size: 14px;
            color: #666;
            cursor: pointer;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: .4s;
            border-radius: 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 6px;
            font-size: 12px;
        }
        
        .slider .moon-emoji,
        .slider .sun-emoji {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            transition: opacity .4s;
            pointer-events: none;
        }
        
        .slider .moon-emoji {
            left: 6px;
            opacity: 0;
        }
        
        .slider .sun-emoji {
            right: 6px;
            opacity: 1;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #667eea;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        input:checked + .slider .moon-emoji {
            opacity: 1;
        }
        
        input:checked + .slider .sun-emoji {
            opacity: 0;
        }
        
        .thread-container {
            padding: 0;
        }
        
        .thread-box {
            border-bottom: 1px solid #e0e0e0;
            position: relative;
        }
        
        .thread-box:last-child {
            border-bottom: none;
        }
        
        .box-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px 10px 30px;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .box-number {
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
            letter-spacing: -0.01em;
        }
        
        .box-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delete-box {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .delete-box:hover {
            background: #ff3742;
        }
        
        .copy-btn {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .copy-btn:hover {
            background: #f8f9fa;
            color: #2ed573;
            border-color: #2ed573;
            transform: translateY(-1px);
        }
        
        .copy-btn:active {
            transform: translateY(0);
            background: #f0f0f0;
        }
        
        .copy-btn svg {
            transition: all 0.2s ease;
        }
        
        .copy-btn:hover svg {
            transform: scale(1.1);
        }
        
        .editor-section {
            padding: 20px 30px;
        }
        
        .latex-input {
            margin-bottom: 15px;
        }
        
        .latex-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: #555;
            letter-spacing: -0.01em;
        }
        
        .CodeMirror {
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            font-weight: 400;
        }
        
        .CodeMirror-focused {
            border-color: #667eea;
        }
        
        .unicode-output label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: #555;
            letter-spacing: -0.01em;
        }
        
        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .output-header label {
            margin-bottom: 0;
        }
        
        .output-box {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            background: #fafafa;
            min-height: 80px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            font-weight: 400;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .output-box a {
            color: #667eea;
            text-decoration: underline;
            word-break: break-all;
        }
        
        .output-box a:hover {
            color: #5a6fd8;
            text-decoration: none;
        }
        
        .char-counter {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .char-counter.over-limit {
            color: #ff4757;
            border-color: #ff4757;
            background: rgba(255, 71, 87, 0.1);
        }
        
        .char-counter.near-limit {
            color: #ffa726;
            border-color: #ffa726;
            background: rgba(255, 167, 38, 0.1);
        }
        
        .unicode-output {
            position: relative;
            margin-top: 15px;
        }
        
        .image-section {
            margin-top: 15px;
        }
        
        .image-container {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            background: #fafafa;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100px;
            position: relative;
        }
        
        .image-container img {
            max-width: 100%;
            max-height: 300px;
            height: auto;
            width: auto;
            border-radius: 4px;
        }
        
        .remove-image-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
            transition: all 0.2s ease;
        }
        
        .remove-image-btn:hover {
            background: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }
        
        .editor-section.drag-over {
            background: rgba(102, 126, 234, 0.1);
            border: 2px dashed #667eea;
        }
        
        .thread-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 15px 0;
            position: relative;
        }
        
        .final-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 15px 0 30px 0;
            position: relative;
        }
        
        .add-box-btn {
            position: absolute;
            right: 20px;
            top: -12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
        }
        
        .add-box-btn:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1001;
        }
        
        .modal h3 {
            margin-top: 0;
            color: #333;
            font-weight: 600;
            font-size: 18px;
            letter-spacing: -0.01em;
        }
        
        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
        }
        
        .modal-btn.cancel {
            background: #ddd;
            color: #333;
        }
        
        .modal-btn.delete {
            background: #ff4757;
            color: white;
        }
        
        .modal-btn:hover {
            opacity: 0.9;
        }
        
        /* Dark Mode Styles */
        body.dark-mode {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        
        body.dark-mode .container {
            background: #2d2d2d;
            box-shadow: 0 2px 20px rgba(0,0,0,0.3);
        }
        
        body.dark-mode .header {
            background: #4a5568;
        }
        
        body.dark-mode .controls {
            background: #363636;
            border-bottom: 1px solid #4a4a4a;
        }
        
        body.dark-mode .platform-selector label,
        body.dark-mode .checkbox-text {
            color: #b0b0b0;
        }
        
        body.dark-mode .platform-selector select {
            background: #404040;
            border: 2px solid #555;
            color: #e0e0e0;
            font-family: 'Inter', sans-serif;
        }
        
        body.dark-mode .platform-selector select:focus {
            border-color: #667eea;
        }
        
        body.dark-mode .thread-box {
            border-bottom: 1px solid #4a4a4a;
        }
        
        body.dark-mode .box-header {
            background: #363636;
            border-bottom: 1px solid #4a4a4a;
        }
        
        body.dark-mode .box-number {
            color: #667eea;
        }
        
        body.dark-mode .editor-section {
            background: #2d2d2d;
        }
        
        body.dark-mode .latex-input label,
        body.dark-mode .unicode-output label {
            color: #b0b0b0;
        }
        
        body.dark-mode .CodeMirror {
            background: #404040;
            border: 2px solid #555;
            color: #e0e0e0;
        }
        
        body.dark-mode .CodeMirror .cm-s-default {
            font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
        }
        
        body.dark-mode .CodeMirror-focused {
            border-color: #667eea;
        }
        
        body.dark-mode .CodeMirror-cursor {
            border-left: 1px solid #e0e0e0;
        }
        
        body.dark-mode .output-box {
            background: #404040;
            border: 2px solid #555;
            color: #e0e0e0;
        }
        
        body.dark-mode .output-box a {
            color: #8bb5ff;
        }
        
        body.dark-mode .output-box a:hover {
            color: #a5c7ff;
        }
        
        body.dark-mode .image-container {
            background: #404040;
            border: 2px solid #555;
        }
        
        body.dark-mode .editor-section.drag-over {
            background: rgba(139, 181, 255, 0.1);
            border: 2px dashed #8bb5ff;
        }
        
        body.dark-mode .remove-image-btn {
            background: rgba(255, 255, 255, 0.5);
            color: black;
        }
        
        body.dark-mode .remove-image-btn:hover {
            background: rgba(255, 255, 255, 0.7);
        }
        
        body.dark-mode .copy-all-btn {
            background: transparent;
            color: #b0b0b0;
            border: 1px solid #555;
        }
        
        body.dark-mode .copy-all-btn:hover {
            background: #404040;
            color: #48bb78;
            border-color: #48bb78;
        }
        
        body.dark-mode .char-counter {
            background: rgba(45, 45, 45, 0.95);
            border-color: #555;
            color: #b0b0b0;
        }
        
        body.dark-mode .char-counter.over-limit {
            color: #ff6b6b;
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }
        
        body.dark-mode .char-counter.near-limit {
            color: #ffb74d;
            border-color: #ffb74d;
            background: rgba(255, 183, 77, 0.1);
        }
        
        body.dark-mode .copy-btn {
            background: transparent;
            color: #b0b0b0;
            border: 1px solid #555;
        }
        
        body.dark-mode .copy-btn:hover {
            background: #404040;
            color: #48bb78;
            border-color: #48bb78;
        }
        
        body.dark-mode .copy-btn:active {
            background: #353535;
        }
        
        body.dark-mode .delete-box {
            background: #e53e3e;
        }
        
        body.dark-mode .delete-box:hover {
            background: #c53030;
        }
        
        body.dark-mode .add-box-btn {
            background: #667eea;
        }
        
        body.dark-mode .add-box-btn:hover {
            background: #5a6fd8;
        }
        
        body.dark-mode .thread-separator,
        body.dark-mode .final-separator {
            background: #4a4a4a;
        }
        
        body.dark-mode .modal-overlay {
            background: rgba(0,0,0,0.7);
        }
        
        body.dark-mode .modal {
            background: #2d2d2d;
            color: #e0e0e0;
        }
        
        body.dark-mode .modal h3 {
            color: #e0e0e0;
        }
        
        body.dark-mode .modal-btn.cancel {
            background: #4a4a4a;
            color: #e0e0e0;
        }
        
        body.dark-mode .modal-btn.delete {
            background: #e53e3e;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <div class="header-text">
                    <p><a href="https://github.com/keenancrane/latweet"><img src="logo.svg" width="200"></a></p>
                    <p>Long-form microblog authoring with rich text and math support.</p>
                </div>
                <div class="theme-toggle">
                    <label for="darkMode">
                        <div class="toggle-switch">
                            <input type="checkbox" id="darkMode" checked>
                            <span class="slider">
                                <span class="moon-emoji">🌙</span>
                                <span class="sun-emoji">☀️</span>
                            </span>
                        </div>
                    </label>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="platform-selector">
                <label for="platform">Platform:</label>
                <select id="platform">
                    <option value="twitter">X/Twitter (280 chars)</option>
                    <option value="threads">Threads (500 chars)</option>
                    <option value="bluesky">BlueSky (300 chars)</option>
                    <option value="mastodon">Mastodon (500 chars)</option>
                    <option value="truth">Truth Social (500 chars)</option>
                </select>
            </div>
            <div class="platform-selector">
                <label for="enumerate">Enumerate:</label>
                <select id="enumerate">
                    <option value="none">None</option>
                    <option value="n">[&lt;i&gt;/n]</option>
                    <option value="total">[&lt;i&gt;/&lt;N&gt;]</option>
                </select>
            </div>
            <div class="checkbox-group">
                <label for="smartBreaking" class="checkbox-label">
                    <input type="checkbox" id="smartBreaking" checked>
                    <span class="checkbox-text">Smart breaking</span>
                </label>
            </div>
            <div class="checkbox-group">
                <label for="enableLatex" class="checkbox-label">
                    <input type="checkbox" id="enableLatex" checked>
                    <span class="checkbox-text">LaTeX</span>
                </label>
            </div>
            <div class="checkbox-group">
                <label for="enableMarkdown" class="checkbox-label">
                    <input type="checkbox" id="enableMarkdown" checked>
                    <span class="checkbox-text">Markdown</span>
                </label>
            </div>
        </div>
        
        <div class="thread-container" id="threadContainer">
            <!-- Thread boxes will be dynamically inserted here -->
        </div>
    </div>
    
    <!-- Delete confirmation modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h3>Delete Thread Box</h3>
            <p>Are you sure you want to delete this thread box and all its content?</p>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeModal()">Cancel</button>
                <button class="modal-btn delete" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/stex/stex.min.js"></script>
    
    <!-- Twitter Text Character Counting - Ported from official twitter-text library -->
    <script>
        // Ported from official Twitter Text library
        // Uses the exact same algorithm and configuration as Twitter
        window.TwitterTextUtils = {
            // Twitter's official configuration (v3)
            config: {
                version: 3,
                maxWeightedTweetLength: 280,
                scale: 100,
                defaultWeight: 200,
                emojiParsingEnabled: true,
                transformedURLLength: 23,
                ranges: [
                    { start: 0, end: 4351, weight: 100 },      // Basic Latin to Hangul
                    { start: 8192, end: 8205, weight: 100 },   // General Punctuation  
                    { start: 8208, end: 8223, weight: 100 },   // General Punctuation
                    { start: 8242, end: 8247, weight: 100 }    // General Punctuation
                ]
            },
            
            // URL detection regex (simplified version of Twitter's extractUrl)
            urlRegex: /(^|[^\/\w])((https?:\/\/)?([a-zA-Z0-9\-]+\.)+[a-zA-Z]{2,}(:\d+)?(\/[^\s]*)?)/gi,
            
            // Extract URLs with their positions
            extractUrlsWithIndices: function(text) {
                const urls = [];
                let match;
                
                // Reset regex
                this.urlRegex.lastIndex = 0;
                
                while ((match = this.urlRegex.exec(text)) !== null) {
                    const fullMatch = match[0];
                    const precedingChar = match[1];
                    const url = match[2];
                    
                    // Calculate actual start position (excluding preceding char)
                    const startIndex = match.index + precedingChar.length;
                    const endIndex = startIndex + url.length;
                    
                    // Basic validation - must have at least one dot
                    if (url.includes('.')) {
                        urls.push({
                            url: url,
                            indices: [startIndex, endIndex]
                        });
                    }
                }
                
                return urls;
            },
            
            // Transform entities array to hash map for fast lookup
            transformEntitiesToHash: function(entities) {
                return entities.reduce((map, entity) => {
                    map[entity.indices[0]] = entity;
                    return map;
                }, {});
            },
            
            // Exact port of Twitter's getCharacterWeight function
            getCharacterWeight: function(ch, options = this.config) {
                const { defaultWeight, ranges } = options;
                let weight = defaultWeight;
                const chCodePoint = ch.charCodeAt(0);
                
                if (Array.isArray(ranges)) {
                    for (let i = 0, length = ranges.length; i < length; i++) {
                        const currRange = ranges[i];
                        if (chCodePoint >= currRange.start && chCodePoint <= currRange.end) {
                            weight = currRange.weight;
                            break;
                        }
                    }
                }
                
                return weight;
            },
            
            // Check if character is a surrogate pair
            isSurrogatePair: function(text, cIndex) {
                if (cIndex < text.length - 1) {
                    const c = text.charCodeAt(cIndex);
                    const cNext = text.charCodeAt(cIndex + 1);
                    return 0xd800 <= c && c <= 0xdbff && (0xdc00 <= cNext && cNext <= 0xdfff);
                }
                return false;
            },
            
            // Complete implementation of Twitter's parseTweet function with URL handling
            parseTweet: function(text = '', options = this.config) {
                const { defaultWeight, scale, maxWeightedTweetLength, transformedURLLength } = options;
                const normalizedText = typeof String.prototype.normalize === 'function' ? text.normalize() : text;
                const tweetLength = normalizedText.length;
                
                // Extract URLs and create lookup hash
                const urlEntitiesMap = this.transformEntitiesToHash(this.extractUrlsWithIndices(normalizedText));
                
                let weightedLength = 0;
                let valid = true;
                
                // Go through every character and calculate weight
                for (let charIndex = 0; charIndex < tweetLength; charIndex++) {
                    // If a URL begins at the specified index, add constant length
                    if (urlEntitiesMap[charIndex]) {
                        const { url, indices } = urlEntitiesMap[charIndex];
                        weightedLength += transformedURLLength * scale;
                        charIndex += url.length - 1; // Skip the rest of the URL
                    } else {
                        charIndex += this.isSurrogatePair(normalizedText, charIndex) ? 1 : 0;
                        weightedLength += this.getCharacterWeight(normalizedText.charAt(charIndex), options);
                    }
                }
                
                weightedLength = weightedLength / scale;
                valid = valid && weightedLength > 0 && weightedLength <= maxWeightedTweetLength;
                
                return {
                    weightedLength,
                    valid
                };
            },
            
            // Convenience function 
            getTweetLength: function(text) {
                return this.parseTweet(text).weightedLength;
            }
        };
        
    </script>
    
    <!-- Unicode data -->
    <script src="unicode-data.js"></script>
    
    <script>
        // Platform character limits
        const PLATFORM_LIMITS = {
            twitter: 280,
            threads: 500,
            bluesky: 300,
            mastodon: 500,
            truth: 500
        };
        
        // Thread management
        let threadBoxes = [];
        let nextBoxId = 1;
        let deleteBoxId = null;
        
        // Character counting function using official Twitter rules
        function getAccurateCharacterCount(text, platform) {
            // For Twitter/X, use the official Twitter text counting logic
            if (platform === 'twitter' && window.TwitterTextUtils && window.TwitterTextUtils.getTweetLength) {
                return window.TwitterTextUtils.getTweetLength(text);
            }
            
            // For other platforms, use basic character count (they don't have special URL handling)
            return text.length;
        }
        
        // Unicode conversion functions (ported from unicodeit)
        function replaceUnicode(text) {
            let result = text;
            
            // Handle \not commands
            result = result.replace(/\\not(\\[A-z]+)/g, '\\slash{$1}');
            
            // Escape combining marks with space
            for (const mark of combiningmarks) {
                const pattern = mark[0];
                let i = -1;
                while ((i = result.indexOf(pattern, i + 1)) > -1 && result.indexOf("}", i + 1) > i) {
                    result = result.slice(0, i + 1) + ' ' + result.slice(i + 1);
                }
            }
            
            // Apply replacements
            for (const replacement of replacements) {
                const pattern = replacement[0];
                const unicode = replacement[1];
                result = result.split(pattern).join(unicode);
                
                if (pattern.slice(-2) === '{}') {
                    result = result.split('\\ ' + pattern.slice(1)).join(unicode);
                }
            }
            
            // Expand subscript groups: _{01234}
            let isub = -1;
            while ((isub = result.indexOf("_{", isub + 1)) > -1 && result.indexOf("}", isub + 1) > isub) {
                result = result.slice(0, isub) + '_' + result[isub + 2] + '_{' + result.slice(isub + 3);
                result = result.replace('_{}', '');
            }
            
            // Expand superscript groups: ^{01234}
            let isup = -1;
            while ((isup = result.indexOf("^{", isup + 1)) > -1 && result.indexOf("}", isup + 1) > isup) {
                result = result.slice(0, isup) + '^' + result[isup + 2] + '^{' + result.slice(isup + 3);
                result = result.replace('^{}', '');
            }
            
            // Apply subsuperscripts
            for (const sub of subsuperscripts) {
                result = result.split(sub[0]).join(sub[1]);
            }
            
            // Apply combining marks
            for (const mark of combiningmarks) {
                const pattern = '\\ ' + mark[0].slice(1) + '{';
                let i = -1;
                while ((i = result.indexOf(pattern, i + 1)) > -1 && result.indexOf("}", i + 1) > i) {
                    const newString = result[i + mark[0].length + 2] + mark[1];
                    result = result.slice(0, i) + newString + result.slice(i + 1 + mark[0].length + 3);
                }
            }
            
            return result;
        }
        
        // Unicode font mappings (from unicode-formatter)
        const unicodeFonts = {
            normal: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~",
            sansBold: "\"\\ !#$%&'()*+,-./𝟬𝟭𝟮𝟯𝟰𝟱𝟲𝟳𝟴𝟵:;<=>?@𝗔𝗕𝗖𝗗𝗘𝗙𝗚𝗛𝗜𝗝𝗞𝗟𝗠𝗡𝗢𝗣𝗤𝗥𝗦𝗧𝗨𝗩𝗪𝗫𝗬𝗭[]^_`𝗮𝗯𝗰𝗱𝗲𝗳𝗴𝗵𝗶𝗷𝗸𝗹𝗺𝗻𝗼𝗽𝗾𝗿𝘀𝘁𝘂𝘃𝘄𝘅𝘆𝘇{|}~",
            sansItalic: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@𝘈𝘉𝘊𝘋𝘌𝘍𝘎𝘏𝘐𝘑𝘒𝘓𝘔𝘕𝘖𝘗𝘘𝘙𝘚𝘛𝘜𝘝𝘞𝘟𝘠𝘡[]^_`𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻{|}~",
            sansBoldItalic: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@𝘼𝘽𝘾𝘿𝙀𝙁𝙂𝙃𝙄𝙅𝙆𝙇𝙈𝙉𝙊𝙋𝙌𝙍𝙎𝙏𝙐𝙑𝙒𝙓𝙔𝙕[]^_`𝙖𝙗𝙘𝙙𝙚𝙛𝙜𝙝𝙞𝙟𝙠𝙡𝙢𝙣𝙤𝙥𝙦𝙧𝙨𝙩𝙪𝙫𝙬𝙭𝙮𝙯{|}~",
            monospace: "\"\\ !#$%&'()*+,-./𝟶𝟷𝟸𝟹𝟺𝟻𝟼𝟽𝟾𝟿:;<=>?@𝙰𝙱𝙲𝙳𝙴𝙵𝙶𝙷𝙸𝙹𝙺𝙻𝙼𝙽𝙾𝙿𝚀𝚁𝚂𝚃𝚄𝚅𝚆𝚇𝚈𝚉[]^_`𝚊𝚋𝚌𝚍𝚎𝚏𝚐𝚑𝚒𝚓𝚔𝚕𝚖𝚗𝚘𝚙𝚚𝚛𝚜𝚝𝚞𝚟𝚠𝚡𝚢𝚣{|}~",
            sans: "\"\\ !#$%&'()*+,-./𝟢𝟣𝟤𝟥𝟦𝟧𝟨𝟩𝟪𝟫:;<=>?@𝖠𝖡𝖢𝖣𝖤𝖥𝖦𝖧𝖨𝖩𝖪𝖫𝖬𝖭𝖮𝖯𝖰𝖱𝖲𝖳𝖴𝖵𝖶𝖷𝖸𝖹[]^_`𝖺𝖻𝖼𝖽𝖾𝖿𝗀𝗁𝗂𝗃𝗄𝗅𝗆𝗇𝗈𝗉𝗊𝗋𝗌𝗍𝗎𝗏𝗐𝗑𝗒𝗓{|}~",
            fraktur: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@𝔄𝔅ℭ𝔇𝔈𝔉𝔊ℌℑ𝔍𝔎𝔏𝔐𝔑𝔒𝔓𝔔ℜ𝔖𝔗𝔘𝔙𝔚𝔛𝔜ℨ[]^_`𝔞𝔟𝔠𝔡𝔢𝔣𝔤𝔥𝔦𝔧𝔨𝔩𝔪𝔫𝔬𝔭𝔮𝔯𝔰𝔱𝔲𝔳𝔴𝔵𝔶𝔷{|}~"
        };
        
        // Convert text using Unicode font mapping
        function convertToUnicodeFont(text, targetFont) {
            const normalChars = Array.from(unicodeFonts.normal);
            const targetChars = Array.from(unicodeFonts[targetFont]);
            
            return Array.from(text).map(char => {
                const index = normalChars.indexOf(char);
                return index !== -1 ? targetChars[index] : char;
            }).join('');
        }
        
        // Text formatting functions
        function applyTextFormatting(text) {
            // Handle nested bold+italic first
            text = text.replace(/\\textbf\{([^{}]*\\textit\{[^{}]*\}[^{}]*)\}/g, (match, content) => {
                return convertToUnicodeFont(content.replace(/\\textit\{([^{}]*)\}/g, '$1'), 'sansBoldItalic');
            });
            
            text = text.replace(/\\textit\{([^{}]*\\textbf\{[^{}]*\}[^{}]*)\}/g, (match, content) => {
                return convertToUnicodeFont(content.replace(/\\textbf\{([^{}]*)\}/g, '$1'), 'sansBoldItalic');
            });
            
            // Handle individual formatting
            text = text.replace(/\\textbf\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sansBold'));
            text = text.replace(/\\textit\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sansItalic'));
            text = text.replace(/\\emph\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sansItalic'));
            text = text.replace(/\\texttt\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'monospace'));
            text = text.replace(/\\mathrm\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sans'));
            
            return text;
        }
        
        // Process math content with support for \mathfrak
        function processMathContent(mathContent) {
            // Handle \mathfrak first (before general replacements)
            mathContent = mathContent.replace(/\\mathfrak\{([^{}]*)\}/g, (match, content) => {
                return convertToUnicodeFont(content, 'fraktur');
            });
            
            // Apply general math replacements
            return replaceUnicode(mathContent);
        }
        
        // Markdown processing functions
        function processMarkdownCode(text) {
            // Process triple backtick code blocks
            text = text.replace(/```[\s\S]*?```/g, (match) => {
                // Convert everything inside to monospace, including any LaTeX
                const codeContent = match.slice(3, -3);
                return convertToMonospace(codeContent);
            });
            
            // Process single backtick inline code
            text = text.replace(/`([^`]+)`/g, (match, codeContent) => {
                return convertToMonospace(codeContent);
            });
            
            return text;
        }
        
        function convertToMonospace(text) {
            // Convert text to Unicode monospace characters
            const monospaceMap = {
                'a': '𝚊', 'b': '𝚋', 'c': '𝚌', 'd': '𝚍', 'e': '𝚎', 'f': '𝚏', 'g': '𝚐', 'h': '𝚑', 'i': '𝚒', 'j': '𝚓',
                'k': '𝚔', 'l': '𝚕', 'm': '𝚖', 'n': '𝚗', 'o': '𝚘', 'p': '𝚙', 'q': '𝚚', 'r': '𝚛', 's': '𝚜', 't': '𝚝',
                'u': '𝚞', 'v': '𝚟', 'w': '𝚠', 'x': '𝚡', 'y': '𝚢', 'z': '𝚣',
                'A': '𝙰', 'B': '𝙱', 'C': '𝙲', 'D': '𝙳', 'E': '𝙴', 'F': '𝙵', 'G': '𝙶', 'H': '𝙷', 'I': '𝙸', 'J': '𝙹',
                'K': '𝙺', 'L': '𝙻', 'M': '𝙼', 'N': '𝙽', 'O': '𝙾', 'P': '𝙿', 'Q': '𝚀', 'R': '𝚁', 'S': '𝚂', 'T': '𝚃',
                'U': '𝚄', 'V': '𝚅', 'W': '𝚆', 'X': '𝚇', 'Y': '𝚈', 'Z': '𝚉',
                '0': '𝟶', '1': '𝟷', '2': '𝟸', '3': '𝟹', '4': '𝟺', '5': '𝟻', '6': '𝟼', '7': '𝟽', '8': '𝟾', '9': '𝟿'
            };
            
            return text.split('').map(char => monospaceMap[char] || char).join('');
        }
        
        function freezeSegments(text) {
            const segments = [];
            let result = text;
            let segmentId = 0;
            
            // Freeze LaTeX math expressions (display math)
            result = result.replace(/\s*\\\[\s*[\s\S]*?\s*\\\]\s*/g, (match) => {
                const id = `§FROZEN§${segmentId++}§`;
                segments.push({ id, content: match, type: 'latex' });
                return id;
            });
            
            // Freeze LaTeX math expressions (inline math - parentheses)
            result = result.replace(/\\\([^\\]*?(?:\\.[^\\]*?)*\\\)/g, (match) => {
                const id = `§FROZEN§${segmentId++}§`;
                segments.push({ id, content: match, type: 'latex' });
                return id;
            });
            
            // Freeze LaTeX math expressions (inline math - dollar signs)
            result = result.replace(/\$[^$]+\$/g, (match) => {
                const id = `§FROZEN§${segmentId++}§`;
                segments.push({ id, content: match, type: 'latex' });
                return id;
            });
            
            // Freeze LaTeX text commands
            result = result.replace(/\\(?:textbf|textit|emph|texttt)\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g, (match) => {
                const id = `§FROZEN§${segmentId++}§`;
                segments.push({ id, content: match, type: 'latex' });
                return id;
            });
            
            // Freeze URLs
            result = result.replace(/https?:\/\/[^\s]+/g, (match) => {
                const id = `§FROZEN§${segmentId++}§`;
                segments.push({ id, content: match, type: 'url' });
                return id;
            });
            
            return { text: result, segments };
        }
        
        function processMarkdownFormatting(text) {
            // Process Markdown formatting on unfrozen text
            // Handle escaped characters first
            text = text.replace(/\\([*_`])/g, '__ESCAPED_$1__');
            
            // Bold and italic (***text***)
            text = text.replace(/\*\*\*([^*]+)\*\*\*/g, (match, content) => {
                return convertToBoldItalic(content);
            });
            
            // Bold (**text**)
            text = text.replace(/\*\*([^*]+)\*\*/g, (match, content) => {
                return convertToBold(content);
            });
            
            // Italic (*text*)
            text = text.replace(/\*([^*]+)\*/g, (match, content) => {
                return convertToItalic(content);
            });
            
            // Bold (__text__)
            text = text.replace(/__([^_]+)__/g, (match, content) => {
                return convertToBold(content);
            });
            
            // Italic (_text_)
            text = text.replace(/_([^_]+)_/g, (match, content) => {
                return convertToItalic(content);
            });
            
            // Restore escaped characters
            text = text.replace(/__ESCAPED_([*_`])__/g, '$1');
            
            return text;
        }
        
        function convertToBold(text) {
            const boldMap = {
                'a': '𝐚', 'b': '𝐛', 'c': '𝐜', 'd': '𝐝', 'e': '𝐞', 'f': '𝐟', 'g': '𝐠', 'h': '𝐡', 'i': '𝐢', 'j': '𝐣',
                'k': '𝐤', 'l': '𝐥', 'm': '𝐦', 'n': '𝐧', 'o': '𝐨', 'p': '𝐩', 'q': '𝐪', 'r': '𝐫', 's': '𝐬', 't': '𝐭',
                'u': '𝐮', 'v': '𝐯', 'w': '𝐰', 'x': '𝐱', 'y': '𝐲', 'z': '𝐳',
                'A': '𝐀', 'B': '𝐁', 'C': '𝐂', 'D': '𝐃', 'E': '𝐄', 'F': '𝐅', 'G': '𝐆', 'H': '𝐇', 'I': '𝐈', 'J': '𝐉',
                'K': '𝐊', 'L': '𝐋', 'M': '𝐌', 'N': '𝐍', 'O': '𝐎', 'P': '𝐏', 'Q': '𝐐', 'R': '𝐑', 'S': '𝐒', 'T': '𝐓',
                'U': '𝐔', 'V': '𝐕', 'W': '𝐖', 'X': '𝐗', 'Y': '𝐘', 'Z': '𝐙',
                '0': '𝟎', '1': '𝟏', '2': '𝟐', '3': '𝟑', '4': '𝟒', '5': '𝟓', '6': '𝟔', '7': '𝟕', '8': '𝟖', '9': '𝟗'
            };
            
            return text.split('').map(char => boldMap[char] || char).join('');
        }
        
        function convertToItalic(text) {
            const italicMap = {
                'a': '𝑎', 'b': '𝑏', 'c': '𝑐', 'd': '𝑑', 'e': '𝑒', 'f': '𝑓', 'g': '𝑔', 'h': 'ℎ', 'i': '𝑖', 'j': '𝑗',
                'k': '𝑘', 'l': '𝑙', 'm': '𝑚', 'n': '𝑛', 'o': '𝑜', 'p': '𝑝', 'q': '𝑞', 'r': '𝑟', 's': '𝑠', 't': '𝑡',
                'u': '𝑢', 'v': '𝑣', 'w': '𝑤', 'x': '𝑥', 'y': '𝑦', 'z': '𝑧',
                'A': '𝐴', 'B': '𝐵', 'C': '𝐶', 'D': '𝐷', 'E': '𝐸', 'F': '𝐹', 'G': '𝐺', 'H': '𝐻', 'I': '𝐼', 'J': '𝐽',
                'K': '𝐾', 'L': '𝐿', 'M': '𝑀', 'N': '𝑁', 'O': '𝑂', 'P': '𝑃', 'Q': '𝑄', 'R': '𝑅', 'S': '𝑆', 'T': '𝑇',
                'U': '𝑈', 'V': '𝑉', 'W': '𝑊', 'X': '𝑋', 'Y': '𝑌', 'Z': '𝑍'
            };
            
            return text.split('').map(char => italicMap[char] || char).join('');
        }
        
        function convertToBoldItalic(text) {
            const boldItalicMap = {
                'a': '𝒂', 'b': '𝒃', 'c': '𝒄', 'd': '𝒅', 'e': '𝒆', 'f': '𝒇', 'g': '𝒈', 'h': '𝒉', 'i': '𝒊', 'j': '𝒋',
                'k': '𝒌', 'l': '𝒍', 'm': '𝒎', 'n': '𝒏', 'o': '𝒐', 'p': '𝒑', 'q': '𝒒', 'r': '𝒓', 's': '𝒔', 't': '𝒕',
                'u': '𝒖', 'v': '𝒗', 'w': '𝒘', 'x': '𝒙', 'y': '𝒚', 'z': '𝒛',
                'A': '𝑨', 'B': '𝑩', 'C': '𝑪', 'D': '𝑫', 'E': '𝑬', 'F': '𝑭', 'G': '𝑮', 'H': '𝑯', 'I': '𝑰', 'J': '𝑱',
                'K': '𝑲', 'L': '𝑳', 'M': '𝑴', 'N': '𝑵', 'O': '𝑶', 'P': '𝑷', 'Q': '𝑸', 'R': '𝑹', 'S': '𝑺', 'T': '𝑻',
                'U': '𝑼', 'V': '𝑽', 'W': '𝑾', 'X': '𝑿', 'Y': '𝒀', 'Z': '𝒁'
            };
            
            return text.split('').map(char => boldItalicMap[char] || char).join('');
        }
        
        function unfreezeSegments(text, segments) {
            let result = text;
            
            // Replace frozen segments back with their processed content
            segments.forEach(segment => {
                if (segment.type === 'latex') {
                    result = result.replace(segment.id, processLatexSegment(segment.content));
                } else if (segment.type === 'url') {
                    result = result.replace(segment.id, segment.content);
                }
            });
            
            return result;
        }
        
        function processLatexSegment(content) {
            // Process display math delimiters \[ ... \]
            content = content.replace(/\s*\\\[\s*(.*?)\s*\\\]\s*/gs, (match, mathContent) => {
                // Strip internal newlines and whitespace, then process
                const cleanMathContent = mathContent.replace(/\s+/g, ' ').trim();
                const processedMath = processMathContent(cleanMathContent);
                // Add two newlines before/after and ideographic spaces for centering
                return `\n\n　　${processedMath}\n\n`;
            });
            
            // Process inline math delimiters \( ... \) and $ ... $
            content = content.replace(/\\\((.*?)\\\)/g, (match, mathContent) => {
                return processMathContent(mathContent);
            });
            
            content = content.replace(/\$([^$]+)\$/g, (match, mathContent) => {
                return processMathContent(mathContent);
            });
            
            // Process text formatting outside of math mode
            content = applyTextFormatting(content);
            
            return content;
        }
        
        // Main conversion function with multi-stage processing
        function convertLatexToUnicode(input) {
            const enableLatex = document.getElementById('enableLatex').checked;
            const enableMarkdown = document.getElementById('enableMarkdown').checked;
            
            let result = input;
            
            // Stage A: Process inline code and code blocks (if Markdown enabled)
            if (enableMarkdown) {
                result = processMarkdownCode(result);
            }
            
            // Stage B: Freeze LaTeX and URL segments (if either is enabled)
            let segments = [];
            if (enableLatex || enableMarkdown) {
                const frozen = freezeSegments(result);
                result = frozen.text;
                segments = frozen.segments;
            }
            
            // Stage C: Process Markdown formatting on unfrozen text (if Markdown enabled)
            if (enableMarkdown) {
                result = processMarkdownFormatting(result);
            }
            
            // Stage D: Unfreeze and process LaTeX segments (if LaTeX enabled)
            if (enableLatex) {
                result = unfreezeSegments(result, segments);
            } else {
                // If LaTeX is disabled, just put back the original content without processing
                segments.forEach(segment => {
                    if (segment.type === 'latex') {
                        result = result.replace(segment.id, segment.content);
                    } else if (segment.type === 'url') {
                        result = result.replace(segment.id, segment.content);
                    }
                });
            }
            
            return result;
        }
        
        // Smart breaking utilities
        function isInMathMode(text, position) {
            // Count math delimiters before position
            let dollarCount = 0;
            let inParenMath = false;
            let inDisplayMath = false;
            
            for (let i = 0; i < position; i++) {
                if (text[i] === '$' && (i === 0 || text[i-1] !== '\\')) {
                    dollarCount++;
                } else if (i < position - 1 && text.substr(i, 2) === '\\(' && (i === 0 || text[i-1] !== '\\')) {
                    inParenMath = true;
                    i++; // Skip the next character since we consumed '\('
                } else if (i < position - 1 && text.substr(i, 2) === '\\)' && (i === 0 || text[i-1] !== '\\')) {
                    inParenMath = false;
                    i++; // Skip the next character since we consumed '\)'
                } else if (i < position - 1 && text.substr(i, 2) === '\\[' && (i === 0 || text[i-1] !== '\\')) {
                    inDisplayMath = true;
                    i++; // Skip the next character since we consumed '\['
                } else if (i < position - 1 && text.substr(i, 2) === '\\]' && (i === 0 || text[i-1] !== '\\')) {
                    inDisplayMath = false;
                    i++; // Skip the next character since we consumed '\]'
                }
            }
            
            return (dollarCount % 2 === 1) || inParenMath || inDisplayMath;
        }
        
        function isInTextCommand(text, position) {
            // Look for unclosed text commands before position
            const textCommands = ['\\textbf{', '\\textit{', '\\emph{', '\\texttt{'];
            let openCommands = 0;
            
            for (let i = 0; i < position; i++) {
                for (const cmd of textCommands) {
                    if (text.substr(i, cmd.length) === cmd) {
                        openCommands++;
                        i += cmd.length - 1;
                        break;
                    }
                }
                if (text[i] === '}' && openCommands > 0) {
                    openCommands--;
                }
            }
            
            return openCommands > 0;
        }
        
        function shouldDelayBreaking(text) {
            const length = text.length;
            return isInMathMode(text, length) || isInTextCommand(text, length);
        }
        
        function findLastWordBoundary(text) {
            // Find the last word boundary, but don't break inside math expressions or text commands
            const wordBoundaryRegex = /[\s\-\u2013\u2014]/; // whitespace, hyphen, en-dash, em-dash
            
            for (let i = text.length - 1; i >= 0; i--) {
                if (wordBoundaryRegex.test(text[i])) {
                    // Check if this boundary is inside a math expression or text command
                    if (isInMathMode(text, i) || isInTextCommand(text, i)) {
                        // Skip this boundary - it's inside a protected region
                        continue;
                    }
                    // Found a valid boundary, return position after it (start of last word/expression)
                    return i + 1;
                }
            }
            
            // No word boundary found, return 0 (whole text is one word)
            return 0;
        }
        
        function performSmartBreaking(boxId, editor, newBox) {
            const input = editor.getValue();
            
            // Find the last word boundary
            const lastWordStart = findLastWordBoundary(input);
            
            // If no word boundary found or it's at the beginning, do character-based splitting
            if (lastWordStart === 0) {
                return;
            }
            
            // Split the text
            const firstPart = input.substring(0, lastWordStart);
            const secondPart = input.substring(lastWordStart);
            
            // Update the current box with the first part
            editor.setValue(firstPart);
            
            // Set the second part in the new box
            newBox.editor.setValue(secondPart);
            
            // Position cursor at the end of the moved text in the new box
            newBox.editor.setCursor(newBox.editor.lineCount(), 0);
        }
        
        function handlePasteEvent(boxId, editor, changeObj) {
            const smartBreakingEnabled = document.getElementById('smartBreaking').checked;
            const isLastBox = boxId === threadBoxes[threadBoxes.length - 1].id;
            const cursor = editor.getCursor();
            const isAtEnd = cursor.line === editor.lineCount() - 1 && cursor.ch === editor.getLine(cursor.line).length;
            
            // Only apply smart breaking for paste if:
            // 1. Smart breaking is enabled
            // 2. We're in the final box 
            // 3. Cursor is at the end
            if (!smartBreakingEnabled || !isLastBox || !isAtEnd) {
                // Let the paste happen normally
                return;
            }
            
            // Cancel the original paste
            changeObj.cancel();
            
            // Get the pasted text
            const pastedText = changeObj.text.join('\n');
            
            // Simulate typing character by character
            simulateTyping(boxId, editor, pastedText);
        }
        
        function simulateTyping(initialBoxId, initialEditor, text) {
            let currentText = '';
            
            // Add characters one by one and check for breaking after each
            for (let i = 0; i < text.length; i++) {
                currentText += text[i];
                
                // Find the current active box (last box in thread)
                const currentBox = threadBoxes[threadBoxes.length - 1];
                const currentEditor = currentBox.editor;
                
                // Get current content and add the new character
                const currentContent = currentEditor.getValue();
                const newContent = currentContent + text[i];
                
                // Set the new content
                currentEditor.setValue(newContent);
                
                // Position cursor at the end
                const doc = currentEditor.getDoc();
                const lastLine = doc.lastLine();
                const lastLineLength = doc.getLine(lastLine).length;
                currentEditor.setCursor(lastLine, lastLineLength);
                
                // Manually trigger the input change handling
                handleInputChange(currentBox.id, currentEditor);
            }
        }
        
        function makeUrlsClickable(text) {
            // Escape HTML characters first to prevent XSS
            const escapedText = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            
            // URL detection regex (similar to the one used in Twitter character counting)
            const urlRegex = /(https?:\/\/[^\s<>"\[\]]+)/gi;
            
            // Replace URLs with clickable links
            return escapedText.replace(urlRegex, (url) => {
                return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            });
        }
        
        // Image handling functions
        function setupImageDragDrop(boxId) {
            const editorSection = document.querySelector(`[data-box-id="${boxId}"] .editor-section`);
            
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                editorSection.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // Highlight drop area
            ['dragenter', 'dragover'].forEach(eventName => {
                editorSection.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                editorSection.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight(e) {
                editorSection.classList.add('drag-over');
            }
            
            function unhighlight(e) {
                editorSection.classList.remove('drag-over');
            }
            
            // Handle dropped files
            editorSection.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    const file = files[0];
                    if (file.type.startsWith('image/')) {
                        attachImage(boxId, file);
                    }
                }
            }
            
            // Handle image paste
            const box = threadBoxes.find(b => b.id === boxId);
            box.editor.getWrapperElement().addEventListener('paste', function(e) {
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.startsWith('image/')) {
                        e.preventDefault();
                        const file = items[i].getAsFile();
                        attachImage(boxId, file);
                        break;
                    }
                }
            });
        }
        
        function attachImage(boxId, file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const box = threadBoxes.find(b => b.id === boxId);
                box.image = e.target.result;
                
                // Update the display
                const imageSection = document.getElementById(`image-section-${boxId}`);
                const imageElement = document.getElementById(`image-${boxId}`);
                
                imageElement.src = e.target.result;
                imageSection.style.display = 'block';
            };
            reader.readAsDataURL(file);
        }
        
        function removeImage(boxId) {
            const box = threadBoxes.find(b => b.id === boxId);
            box.image = null;
            
            // Hide the image section
            const imageSection = document.getElementById(`image-section-${boxId}`);
            imageSection.style.display = 'none';
            
            // Clear the image source
            const imageElement = document.getElementById(`image-${boxId}`);
            imageElement.src = '';
        }
        
        async function copyImageToClipboard(boxId) {
            const box = threadBoxes.find(b => b.id === boxId);
            if (!box.image) return;
            
            try {
                // Convert base64 to blob
                const response = await fetch(box.image);
                const blob = await response.blob();
                
                // Copy to clipboard
                await navigator.clipboard.write([
                    new ClipboardItem({
                        [blob.type]: blob
                    })
                ]);
                
                // Show success feedback
                const copyBtn = document.querySelector(`[data-box-id="${boxId}"] .image-section .copy-btn`);
                const originalContent = copyBtn.innerHTML;
                const originalTitle = copyBtn.title;
                
                copyBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                `;
                copyBtn.title = 'Copied!';
                copyBtn.style.color = '#2ed573';
                copyBtn.style.borderColor = '#2ed573';
                copyBtn.style.background = '#f0f9f4';
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalContent;
                    copyBtn.title = originalTitle;
                    copyBtn.style.color = '';
                    copyBtn.style.borderColor = '';
                    copyBtn.style.background = '';
                }, 1500);
                
            } catch (err) {
                console.error('Failed to copy image: ', err);
                alert('Failed to copy image to clipboard');
            }
        }
        
        function copyAllInput() {
            // Concatenate all LaTeX input from all posts
            const allInput = threadBoxes.map(box => {
                if (box.editor) {
                    return box.editor.getValue();
                }
                return '';
            }).join('\n\n');
            
            if (!allInput.trim()) {
                alert('No content to copy!');
                return;
            }
            
            navigator.clipboard.writeText(allInput).then(() => {
                const copyBtn = document.querySelector('.copy-all-btn');
                const originalContent = copyBtn.innerHTML;
                
                // Show success state
                copyBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                    Copied!
                `;
                copyBtn.style.background = 'rgba(46, 213, 115, 0.2)';
                copyBtn.style.borderColor = 'rgba(46, 213, 115, 0.5)';
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalContent;
                    copyBtn.style.background = '';
                    copyBtn.style.borderColor = '';
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Get enumeration string for a thread box
        function getEnumerationString(boxId) {
            const enumerationType = document.getElementById('enumerate').value;
            if (enumerationType === 'none') {
                return '';
            }
            
            const boxIndex = threadBoxes.findIndex(box => box.id === boxId);
            const currentNumber = boxIndex + 1;
            
            if (enumerationType === 'n') {
                return ` [${currentNumber}/n]`;
            } else if (enumerationType === 'total') {
                const totalBoxes = threadBoxes.length;
                return ` [${currentNumber}/${totalBoxes}]`;
            }
            
            return '';
        }

        // Thread box management
        function createThreadBox(insertAfter = null) {
            const boxId = nextBoxId++;
            const platform = document.getElementById('platform').value;
            const limit = PLATFORM_LIMITS[platform];
            
            const boxElement = document.createElement('div');
            boxElement.className = 'thread-box';
            boxElement.dataset.boxId = boxId;
            
            const isFirst = threadBoxes.length === 0;
            
            boxElement.innerHTML = `
                <div class="box-header">
                    <div class="box-number">Tweet <span class="box-count">1</span>/<span class="total-count">1</span></div>
                    <div class="box-controls">
                        ${isFirst ? `
                            <button class="copy-all-btn" onclick="copyAllInput()" title="Copy all LaTeX input">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="m5 15v-11a2 2 0 0 1 2 -2h11"></path>
                                </svg>
                                Copy Source
                            </button>
                        ` : `<button class="delete-box" onclick="showDeleteModal(${boxId})">×</button>`}
                    </div>
                </div>
                <div class="editor-section">
                    <div class="latex-input">
                        <label>LaTeX Input:</label>
                        <textarea id="latex-${boxId}"></textarea>
                    </div>
                    <div class="unicode-output">
                        <div class="output-header">
                            <label>Unicode Output:</label>
                            <button class="copy-btn" onclick="copyToClipboard(${boxId})" title="Copy to clipboard">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="m5 15v-11a2 2 0 0 1 2 -2h11"></path>
                                </svg>
                            </button>
                        </div>
                        <div class="output-box" id="output-${boxId}"></div>
                        <div class="char-counter" id="counter-${boxId}">0</div>
                    </div>
                    <div class="image-section" id="image-section-${boxId}" style="display: none;">
                        <div class="output-header">
                            <label>Image:</label>
                            <button class="copy-btn" onclick="copyImageToClipboard(${boxId})" title="Copy image to clipboard">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="m5 15v-11a2 2 0 0 1 2 -2h11"></path>
                                </svg>
                            </button>
                        </div>
                        <div class="image-container">
                            <img id="image-${boxId}" src="" alt="Attached image" />
                            <button class="remove-image-btn" onclick="removeImage(${boxId})" title="Remove image">×</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Insert box in the right position in the array first (before CodeMirror initialization)
            const tempBoxInfo = {
                id: boxId,
                element: boxElement,
                editor: null, // Will be set after CodeMirror is initialized
                limit: limit,
                image: null // Will store base64 image data when attached
            };
            
            if (insertAfter === null) {
                threadBoxes.push(tempBoxInfo);
                
                // If this is the first box, add it directly to the DOM
                if (threadBoxes.length === 1) {
                    const container = document.getElementById('threadContainer');
                    container.appendChild(boxElement);
                    
                    // Add final separator with + button
                    const finalSeparator = document.createElement('div');
                    finalSeparator.className = 'final-separator';
                    finalSeparator.innerHTML = '<button class="add-box-btn" onclick="createThreadBox()">+</button>';
                    container.appendChild(finalSeparator);
                    
                    updateBoxNumbers();
                } else {
                    // Rebuild DOM for subsequent boxes
                    rebuildThreadDOM();
                }
            } else {
                const insertIndex = threadBoxes.findIndex(box => box.id === insertAfter) + 1;
                threadBoxes.splice(insertIndex, 0, tempBoxInfo);
                
                // Rebuild the entire DOM structure to ensure correct ordering
                rebuildThreadDOM();
            }
            
            // Now initialize CodeMirror after the element is in the DOM
            const textarea = document.getElementById(`latex-${boxId}`);
            const editor = CodeMirror.fromTextArea(textarea, {
                mode: 'stex',
                theme: 'default',
                lineNumbers: false,
                lineWrapping: true,
                placeholder: 'Enter LaTeX here...'
            });
            
            // Set up event handlers
            editor.on('change', () => handleInputChange(boxId, editor));
            
            // Handle paste events for smart breaking
            editor.on('beforeChange', (instance, changeObj) => {
                if (changeObj.origin === 'paste') {
                    handlePasteEvent(boxId, editor, changeObj);
                }
            });
            
            // Update the box info with the editor
            const boxInfo = threadBoxes.find(box => box.id === boxId);
            boxInfo.editor = editor;
            
            // Set up drag and drop for images (after editor is assigned)
            setupImageDragDrop(boxId);
            
            // Focus the new editor
            editor.focus();
            
            return boxInfo;
        }
        
        function rebuildThreadDOM() {
            const container = document.getElementById('threadContainer');
            container.innerHTML = '';
            
            threadBoxes.forEach((box, index) => {
                // Update delete button visibility (first box should not have delete button)
                const deleteBtn = box.element.querySelector('.delete-box');
                if (index === 0) {
                    if (deleteBtn) deleteBtn.remove();
                } else {
                    if (!deleteBtn) {
                        const boxControls = box.element.querySelector('.box-controls');
                        const newDeleteBtn = document.createElement('button');
                        newDeleteBtn.className = 'delete-box';
                        newDeleteBtn.onclick = () => showDeleteModal(box.id);
                        newDeleteBtn.textContent = '×';
                        boxControls.appendChild(newDeleteBtn);
                    }
                }
                
                // Add the box
                container.appendChild(box.element);
                
                // Add separator with + button (except after the last box)
                if (index < threadBoxes.length - 1) {
                    const separator = document.createElement('div');
                    separator.className = 'thread-separator';
                    separator.innerHTML = `<button class="add-box-btn" onclick="createThreadBox(${box.id})">+</button>`;
                    container.appendChild(separator);
                }
            });
            
            // Add final separator with + button after the last box
            const finalSeparator = document.createElement('div');
            finalSeparator.className = 'final-separator';
            finalSeparator.innerHTML = '<button class="add-box-btn" onclick="createThreadBox()">+</button>';
            container.appendChild(finalSeparator);
            
            updateBoxNumbers();
        }
        
        function handleInputChange(boxId, editor) {
            const input = editor.getValue();
            const baseOutput = convertLatexToUnicode(input);
            const enumeration = getEnumerationString(boxId);
            const output = baseOutput + enumeration;
            const outputElement = document.getElementById(`output-${boxId}`);
            const counterElement = document.getElementById(`counter-${boxId}`);
            
            // Make URLs clickable and set as HTML
            const htmlOutput = makeUrlsClickable(output);
            outputElement.innerHTML = htmlOutput;
            
            const box = threadBoxes.find(b => b.id === boxId);
            const platform = document.getElementById('platform').value;
            const charCount = getAccurateCharacterCount(output, platform);
            const limit = box.limit;
            
            counterElement.textContent = `${charCount}`;
            
            // Update counter styling based on usage
            counterElement.className = 'char-counter';
            if (charCount >= limit) {
                counterElement.className += ' over-limit';
            } else if (charCount >= limit * 0.9) {
                counterElement.className += ' near-limit';
            }
            
            // Auto-create new box if we hit the limit AND we're in the final box AND cursor is at the end
            const isLastBox = boxId === threadBoxes[threadBoxes.length - 1].id;
            const cursor = editor.getCursor();
            const isAtEnd = cursor.line === editor.lineCount() - 1 && cursor.ch === editor.getLine(cursor.line).length;
            
            if (charCount > limit && isLastBox && isAtEnd) {
                const input = editor.getValue();
                
                // Delay breaking if we're in math mode or unclosed text command
                if (shouldDelayBreaking(input)) {
                    // Don't create new box yet - wait until math/command is closed
                    return;
                }
                
                const newBox = createThreadBox();
                
                // Apply smart breaking if enabled (we already know we exceed the limit)
                const smartBreakingEnabled = document.getElementById('smartBreaking').checked;
                
                if (smartBreakingEnabled) {
                    performSmartBreaking(boxId, editor, newBox);
                } else {
                    // Default behavior: just focus the new box
                    setTimeout(() => newBox.editor.focus(), 100);
                }
            }
        }
        
        function updateBoxNumbers() {
            const total = threadBoxes.length;
            threadBoxes.forEach((box, index) => {
                const boxCountElement = box.element.querySelector('.box-count');
                const totalCountElement = box.element.querySelector('.total-count');
                boxCountElement.textContent = index + 1;
                totalCountElement.textContent = total;
            });
            
            // Update all outputs since enumeration depends on box position and total count
            updateAllEnumeratedOutputs();
        }
        
        function updateAllEnumeratedOutputs() {
            threadBoxes.forEach(box => {
                if (box.editor) {
                    handleInputChange(box.id, box.editor);
                }
            });
        }
        
        function updateAllLimits() {
            const platform = document.getElementById('platform').value;
            const limit = PLATFORM_LIMITS[platform];
            
            threadBoxes.forEach(box => {
                box.limit = limit;
                const counterElement = document.getElementById(`counter-${box.id}`);
                const outputElement = document.getElementById(`output-${box.id}`);
                const charCount = getAccurateCharacterCount(outputElement.textContent, platform);
                
                counterElement.textContent = `${charCount}`;
                
                // Update counter styling based on usage
                counterElement.className = 'char-counter';
                if (charCount >= limit) {
                    counterElement.className += ' over-limit';
                } else if (charCount >= limit * 0.9) {
                    counterElement.className += ' near-limit';
                }
            });
        }
        
        function showDeleteModal(boxId) {
            deleteBoxId = boxId;
            document.getElementById('modalOverlay').style.display = 'block';
        }
        
        function closeModal() {
            deleteBoxId = null;
            document.getElementById('modalOverlay').style.display = 'none';
        }
        
        function confirmDelete() {
            if (deleteBoxId && threadBoxes.length > 1) {
                const boxIndex = threadBoxes.findIndex(box => box.id === deleteBoxId);
                if (boxIndex > -1) {
                    // Remove from array
                    threadBoxes.splice(boxIndex, 1);
                    
                    // Rebuild DOM
                    rebuildThreadDOM();
                    
                    // Focus previous box if available
                    if (boxIndex > 0) {
                        const prevBox = threadBoxes[boxIndex - 1];
                        prevBox.editor.focus();
                        prevBox.editor.setCursor(prevBox.editor.lineCount(), 0);
                    } else if (threadBoxes.length > 0) {
                        threadBoxes[0].editor.focus();
                    }
                }
            }
            closeModal();
        }
        
        function copyToClipboard(boxId) {
            // Get the plain text version (not HTML with links)
            const text = getUnicodeOutputWithEnumeration(boxId);
            
            navigator.clipboard.writeText(text).then(() => {
                const copyBtn = document.querySelector(`[data-box-id="${boxId}"] .copy-btn`);
                const originalContent = copyBtn.innerHTML;
                const originalTitle = copyBtn.title;
                
                // Show success state
                copyBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                `;
                copyBtn.title = 'Copied!';
                copyBtn.style.color = '#2ed573';
                copyBtn.style.borderColor = '#2ed573';
                copyBtn.style.background = '#f0f9f4';
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalContent;
                    copyBtn.title = originalTitle;
                    copyBtn.style.color = '';
                    copyBtn.style.borderColor = '';
                    copyBtn.style.background = '';
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }
        
        // Dark mode functionality
        function initDarkMode() {
            const darkModeToggle = document.getElementById('darkMode');
            const body = document.body;
            
            // Check for saved preference or default to dark mode
            const savedTheme = localStorage.getItem('darkMode');
            const prefersDark = savedTheme !== null ? savedTheme === 'true' : true; // Default to dark
            
            // Apply initial theme
            darkModeToggle.checked = prefersDark;
            if (prefersDark) {
                body.classList.add('dark-mode');
            }
            
            // Toggle functionality
            darkModeToggle.addEventListener('change', function() {
                if (this.checked) {
                    body.classList.add('dark-mode');
                    localStorage.setItem('darkMode', 'true');
                } else {
                    body.classList.remove('dark-mode');
                    localStorage.setItem('darkMode', 'false');
                }
            });
        }
        
        // Event listeners
        document.getElementById('platform').addEventListener('change', updateAllLimits);
        document.getElementById('enumerate').addEventListener('change', updateAllEnumeratedOutputs);
        document.getElementById('enableLatex').addEventListener('change', updateAllEnumeratedOutputs);
        document.getElementById('enableMarkdown').addEventListener('change', updateAllEnumeratedOutputs);
        
        document.getElementById('modalOverlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                closeModal();
            }
        });
        
        // Prevent accidental data loss
        function hasContent() {
            return threadBoxes.some(box => {
                if (box.editor && box.editor.getValue().trim()) {
                    return true;
                }
                if (box.image) {
                    return true;
                }
                return false;
            });
        }
        
        window.addEventListener('beforeunload', function(e) {
            if (hasContent()) {
                e.preventDefault();
                e.returnValue = ''; // Chrome requires returnValue to be set
                return ''; // Some browsers require a return value
            }
        });
        
        // Demo content for landing page
        function loadDemoContent() {
            const demoText = `Hello, La_Tweet!_

Try _italic_/**bold** text with Markdown, or \\textit{with} \\textbf{LaTeX}.

You can format \`code()\` inline or
\`\`\`
in.block.form();
\`\`\`
Likewise, you can write inline math like $x^2$ or display math like
\\[\\int_\\mathcal{M} K dA = 2\\pi\\chi(\\mathcal{M}).\\]

Threads that are too long… …automatically get split across multiple posts.

Also try out other features, like auto-enumeration of posts!

Check out the GitHub repo for more comprehensive documentation:

https://github.com/keenancrane/latweet

_(See the preview for a clickable link!)_`;

            // Wait for the first box to be initialized
            setTimeout(() => {
                const firstBox = threadBoxes[0];
                if (firstBox && firstBox.editor) {
                    // Load the demo content
                    simulateTyping(firstBox.id, firstBox.editor, demoText);
                    
                    // After content loads, snap to top and show everything
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                        document.body.classList.add('loaded');
                        firstBox.editor.focus();
                    }, 300);
                }
            }, 100);
        }

        // Initialize with first thread box and dark mode
        document.addEventListener('DOMContentLoaded', () => {
            initDarkMode();
            createThreadBox();
            loadDemoContent();
        });
    </script>
</body>
</html>
