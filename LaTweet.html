<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaTweet!</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/default.min.css">
    
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 15px;
            line-height: 1.5;
            font-weight: 400;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
            color: #333;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: #667eea;
            color: white;
            padding: 20px 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2em;
            font-weight: 700;
            letter-spacing: -0.02em;
        }
        
        .header p {
            margin: 5px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
            font-weight: 400;
        }
        
        .controls {
            padding: 20px 30px;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .platform-selector {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .platform-selector label {
            font-weight: 500;
            color: #666;
            font-size: 14px;
        }
        
        .platform-selector select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 400;
            color: #333;
        }
        
        .platform-selector select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .theme-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
            font-size: 14px;
            color: #666;
            cursor: pointer;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #667eea;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .thread-container {
            padding: 0;
        }
        
        .thread-box {
            border-bottom: 1px solid #e0e0e0;
            position: relative;
        }
        
        .thread-box:last-child {
            border-bottom: none;
        }
        
        .box-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px 10px 30px;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .box-number {
            font-weight: 600;
            color: #667eea;
            font-size: 14px;
            letter-spacing: -0.01em;
        }
        
        .box-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delete-box {
            background: #ff4757;
            color: white;
            border: none;
            border-radius: 4px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }
        
        .delete-box:hover {
            background: #ff3742;
        }
        
        .copy-btn {
            background: transparent;
            color: #666;
            border: 1px solid #ddd;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            position: relative;
        }
        
        .copy-btn:hover {
            background: #f8f9fa;
            color: #2ed573;
            border-color: #2ed573;
            transform: translateY(-1px);
        }
        
        .copy-btn:active {
            transform: translateY(0);
            background: #f0f0f0;
        }
        
        .copy-btn svg {
            transition: all 0.2s ease;
        }
        
        .copy-btn:hover svg {
            transform: scale(1.1);
        }
        
        .editor-section {
            padding: 20px 30px;
        }
        
        .latex-input {
            margin-bottom: 15px;
        }
        
        .latex-input label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: #555;
            letter-spacing: -0.01em;
        }
        
        .CodeMirror {
            border: 2px solid #ddd;
            border-radius: 8px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            font-weight: 400;
        }
        
        .CodeMirror-focused {
            border-color: #667eea;
        }
        
        .unicode-output label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: #555;
            letter-spacing: -0.01em;
        }
        
        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .output-header label {
            margin-bottom: 0;
        }
        
        .output-box {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            background: #fafafa;
            min-height: 80px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.5;
            font-weight: 400;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .char-counter {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .char-counter.over-limit {
            color: #ff4757;
            border-color: #ff4757;
            background: rgba(255, 71, 87, 0.1);
        }
        
        .char-counter.near-limit {
            color: #ffa726;
            border-color: #ffa726;
            background: rgba(255, 167, 38, 0.1);
        }
        
        .unicode-output {
            position: relative;
            margin-top: 15px;
        }
        
        .thread-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 15px 0;
            position: relative;
        }
        
        .final-separator {
            height: 1px;
            background: #e0e0e0;
            margin: 15px 0 30px 0;
            position: relative;
        }
        
        .add-box-btn {
            position: absolute;
            right: 20px;
            top: -12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 10;
        }
        
        .add-box-btn:hover {
            background: #5a6fd8;
            transform: scale(1.1);
        }
        
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        
        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            z-index: 1001;
        }
        
        .modal h3 {
            margin-top: 0;
            color: #333;
            font-weight: 600;
            font-size: 18px;
            letter-spacing: -0.01em;
        }
        
        .modal-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        .modal-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
        }
        
        .modal-btn.cancel {
            background: #ddd;
            color: #333;
        }
        
        .modal-btn.delete {
            background: #ff4757;
            color: white;
        }
        
        .modal-btn:hover {
            opacity: 0.9;
        }
        
        /* Dark Mode Styles */
        body.dark-mode {
            background-color: #1a1a1a;
            color: #e0e0e0;
        }
        
        body.dark-mode .container {
            background: #2d2d2d;
            box-shadow: 0 2px 20px rgba(0,0,0,0.3);
        }
        
        body.dark-mode .header {
            background: #4a5568;
        }
        
        body.dark-mode .controls {
            background: #363636;
            border-bottom: 1px solid #4a4a4a;
        }
        
        body.dark-mode .platform-selector label,
        body.dark-mode .theme-toggle label {
            color: #b0b0b0;
        }
        
        body.dark-mode .platform-selector select {
            background: #404040;
            border: 2px solid #555;
            color: #e0e0e0;
            font-family: 'Inter', sans-serif;
        }
        
        body.dark-mode .platform-selector select:focus {
            border-color: #667eea;
        }
        
        body.dark-mode .thread-box {
            border-bottom: 1px solid #4a4a4a;
        }
        
        body.dark-mode .box-header {
            background: #363636;
            border-bottom: 1px solid #4a4a4a;
        }
        
        body.dark-mode .box-number {
            color: #667eea;
        }
        
        body.dark-mode .editor-section {
            background: #2d2d2d;
        }
        
        body.dark-mode .latex-input label,
        body.dark-mode .unicode-output label {
            color: #b0b0b0;
        }
        
        body.dark-mode .CodeMirror {
            background: #404040;
            border: 2px solid #555;
            color: #e0e0e0;
        }
        
        body.dark-mode .CodeMirror .cm-s-default {
            font-family: 'JetBrains Mono', 'Fira Code', 'Monaco', 'Consolas', monospace;
        }
        
        body.dark-mode .CodeMirror-focused {
            border-color: #667eea;
        }
        
        body.dark-mode .CodeMirror-cursor {
            border-left: 1px solid #e0e0e0;
        }
        
        body.dark-mode .output-box {
            background: #404040;
            border: 2px solid #555;
            color: #e0e0e0;
        }
        
        body.dark-mode .char-counter {
            background: rgba(45, 45, 45, 0.95);
            border-color: #555;
            color: #b0b0b0;
        }
        
        body.dark-mode .char-counter.over-limit {
            color: #ff6b6b;
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
        }
        
        body.dark-mode .char-counter.near-limit {
            color: #ffb74d;
            border-color: #ffb74d;
            background: rgba(255, 183, 77, 0.1);
        }
        
        body.dark-mode .copy-btn {
            background: transparent;
            color: #b0b0b0;
            border: 1px solid #555;
        }
        
        body.dark-mode .copy-btn:hover {
            background: #404040;
            color: #48bb78;
            border-color: #48bb78;
        }
        
        body.dark-mode .copy-btn:active {
            background: #353535;
        }
        
        body.dark-mode .delete-box {
            background: #e53e3e;
        }
        
        body.dark-mode .delete-box:hover {
            background: #c53030;
        }
        
        body.dark-mode .add-box-btn {
            background: #667eea;
        }
        
        body.dark-mode .add-box-btn:hover {
            background: #5a6fd8;
        }
        
        body.dark-mode .thread-separator,
        body.dark-mode .final-separator {
            background: #4a4a4a;
        }
        
        body.dark-mode .modal-overlay {
            background: rgba(0,0,0,0.7);
        }
        
        body.dark-mode .modal {
            background: #2d2d2d;
            color: #e0e0e0;
        }
        
        body.dark-mode .modal h3 {
            color: #e0e0e0;
        }
        
        body.dark-mode .modal-btn.cancel {
            background: #4a4a4a;
            color: #e0e0e0;
        }
        
        body.dark-mode .modal-btn.delete {
            background: #e53e3e;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
           <p><img src="logo.svg" width="200"></p>
            <p>Long-form microblog authoring tool with rich text and LaTeX.</p>
        </div>
        
        <div class="controls">
            <div class="platform-selector">
                <label for="platform">Platform:</label>
                <select id="platform">
                    <option value="twitter">X/Twitter (280 chars)</option>
                    <option value="threads">Threads (500 chars)</option>
                    <option value="bluesky">BlueSky (300 chars)</option>
                    <option value="mastodon">Mastodon (500 chars)</option>
                    <option value="truth">Truth Social (500 chars)</option>
                </select>
            </div>
            <div class="platform-selector">
                <label for="enumerate">Enumerate:</label>
                <select id="enumerate">
                    <option value="none">None</option>
                    <option value="n">[&lt;i&gt;/n]</option>
                    <option value="total">[&lt;i&gt;/&lt;N&gt;]</option>
                </select>
            </div>
            <div class="platform-selector">
                <label for="smartBreaking">
                    <input type="checkbox" id="smartBreaking" checked>
                    Smart breaking
                </label>
            </div>
            <div class="theme-toggle">
                <label for="darkMode">
                    <span class="toggle-text">Dark Mode</span>
                    <div class="toggle-switch">
                        <input type="checkbox" id="darkMode" checked>
                        <span class="slider"></span>
                    </div>
                </label>
            </div>
        </div>
        
        <div class="thread-container" id="threadContainer">
            <!-- Thread boxes will be dynamically inserted here -->
        </div>
    </div>
    
    <!-- Delete confirmation modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <h3>Delete Thread Box</h3>
            <p>Are you sure you want to delete this thread box and all its content?</p>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="closeModal()">Cancel</button>
                <button class="modal-btn delete" onclick="confirmDelete()">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/stex/stex.min.js"></script>
    
    <!-- Twitter Text Character Counting - Ported from official twitter-text library -->
    <script>
        // Ported from official Twitter Text library
        // Uses the exact same algorithm and configuration as Twitter
        window.TwitterTextUtils = {
            // Twitter's official configuration (v3)
            config: {
                version: 3,
                maxWeightedTweetLength: 280,
                scale: 100,
                defaultWeight: 200,
                emojiParsingEnabled: true,
                transformedURLLength: 23,
                ranges: [
                    { start: 0, end: 4351, weight: 100 },      // Basic Latin to Hangul
                    { start: 8192, end: 8205, weight: 100 },   // General Punctuation  
                    { start: 8208, end: 8223, weight: 100 },   // General Punctuation
                    { start: 8242, end: 8247, weight: 100 }    // General Punctuation
                ]
            },
            
            // URL detection regex (simplified version of Twitter's extractUrl)
            urlRegex: /(^|[^\/\w])((https?:\/\/)?([a-zA-Z0-9\-]+\.)+[a-zA-Z]{2,}(:\d+)?(\/[^\s]*)?)/gi,
            
            // Extract URLs with their positions
            extractUrlsWithIndices: function(text) {
                const urls = [];
                let match;
                
                // Reset regex
                this.urlRegex.lastIndex = 0;
                
                while ((match = this.urlRegex.exec(text)) !== null) {
                    const fullMatch = match[0];
                    const precedingChar = match[1];
                    const url = match[2];
                    
                    // Calculate actual start position (excluding preceding char)
                    const startIndex = match.index + precedingChar.length;
                    const endIndex = startIndex + url.length;
                    
                    // Basic validation - must have at least one dot
                    if (url.includes('.')) {
                        urls.push({
                            url: url,
                            indices: [startIndex, endIndex]
                        });
                    }
                }
                
                return urls;
            },
            
            // Transform entities array to hash map for fast lookup
            transformEntitiesToHash: function(entities) {
                return entities.reduce((map, entity) => {
                    map[entity.indices[0]] = entity;
                    return map;
                }, {});
            },
            
            // Exact port of Twitter's getCharacterWeight function
            getCharacterWeight: function(ch, options = this.config) {
                const { defaultWeight, ranges } = options;
                let weight = defaultWeight;
                const chCodePoint = ch.charCodeAt(0);
                
                if (Array.isArray(ranges)) {
                    for (let i = 0, length = ranges.length; i < length; i++) {
                        const currRange = ranges[i];
                        if (chCodePoint >= currRange.start && chCodePoint <= currRange.end) {
                            weight = currRange.weight;
                            break;
                        }
                    }
                }
                
                return weight;
            },
            
            // Check if character is a surrogate pair
            isSurrogatePair: function(text, cIndex) {
                if (cIndex < text.length - 1) {
                    const c = text.charCodeAt(cIndex);
                    const cNext = text.charCodeAt(cIndex + 1);
                    return 0xd800 <= c && c <= 0xdbff && (0xdc00 <= cNext && cNext <= 0xdfff);
                }
                return false;
            },
            
            // Complete implementation of Twitter's parseTweet function with URL handling
            parseTweet: function(text = '', options = this.config) {
                const { defaultWeight, scale, maxWeightedTweetLength, transformedURLLength } = options;
                const normalizedText = typeof String.prototype.normalize === 'function' ? text.normalize() : text;
                const tweetLength = normalizedText.length;
                
                // Extract URLs and create lookup hash
                const urlEntitiesMap = this.transformEntitiesToHash(this.extractUrlsWithIndices(normalizedText));
                
                let weightedLength = 0;
                let valid = true;
                
                // Go through every character and calculate weight
                for (let charIndex = 0; charIndex < tweetLength; charIndex++) {
                    // If a URL begins at the specified index, add constant length
                    if (urlEntitiesMap[charIndex]) {
                        const { url, indices } = urlEntitiesMap[charIndex];
                        weightedLength += transformedURLLength * scale;
                        charIndex += url.length - 1; // Skip the rest of the URL
                    } else {
                        charIndex += this.isSurrogatePair(normalizedText, charIndex) ? 1 : 0;
                        weightedLength += this.getCharacterWeight(normalizedText.charAt(charIndex), options);
                    }
                }
                
                weightedLength = weightedLength / scale;
                valid = valid && weightedLength > 0 && weightedLength <= maxWeightedTweetLength;
                
                return {
                    weightedLength,
                    valid
                };
            },
            
            // Convenience function 
            getTweetLength: function(text) {
                return this.parseTweet(text).weightedLength;
            }
        };
        
    </script>
    
    <!-- Unicode data -->
    <script src="unicode-data.js"></script>
    
    <script>
        // Platform character limits
        const PLATFORM_LIMITS = {
            twitter: 280,
            threads: 500,
            bluesky: 300,
            mastodon: 500,
            truth: 500
        };
        
        // Thread management
        let threadBoxes = [];
        let nextBoxId = 1;
        let deleteBoxId = null;
        
        // Character counting function using official Twitter rules
        function getAccurateCharacterCount(text, platform) {
            // For Twitter/X, use the official Twitter text counting logic
            if (platform === 'twitter' && window.TwitterTextUtils && window.TwitterTextUtils.getTweetLength) {
                return window.TwitterTextUtils.getTweetLength(text);
            }
            
            // For other platforms, use basic character count (they don't have special URL handling)
            return text.length;
        }
        
        // Unicode conversion functions (ported from unicodeit)
        function replaceUnicode(text) {
            let result = text;
            
            // Handle \not commands
            result = result.replace(/\\not(\\[A-z]+)/g, '\\slash{$1}');
            
            // Escape combining marks with space
            for (const mark of combiningmarks) {
                const pattern = mark[0];
                let i = -1;
                while ((i = result.indexOf(pattern, i + 1)) > -1 && result.indexOf("}", i + 1) > i) {
                    result = result.slice(0, i + 1) + ' ' + result.slice(i + 1);
                }
            }
            
            // Apply replacements
            for (const replacement of replacements) {
                const pattern = replacement[0];
                const unicode = replacement[1];
                result = result.split(pattern).join(unicode);
                
                if (pattern.slice(-2) === '{}') {
                    result = result.split('\\ ' + pattern.slice(1)).join(unicode);
                }
            }
            
            // Expand subscript groups: _{01234}
            let isub = -1;
            while ((isub = result.indexOf("_{", isub + 1)) > -1 && result.indexOf("}", isub + 1) > isub) {
                result = result.slice(0, isub) + '_' + result[isub + 2] + '_{' + result.slice(isub + 3);
                result = result.replace('_{}', '');
            }
            
            // Expand superscript groups: ^{01234}
            let isup = -1;
            while ((isup = result.indexOf("^{", isup + 1)) > -1 && result.indexOf("}", isup + 1) > isup) {
                result = result.slice(0, isup) + '^' + result[isup + 2] + '^{' + result.slice(isup + 3);
                result = result.replace('^{}', '');
            }
            
            // Apply subsuperscripts
            for (const sub of subsuperscripts) {
                result = result.split(sub[0]).join(sub[1]);
            }
            
            // Apply combining marks
            for (const mark of combiningmarks) {
                const pattern = '\\ ' + mark[0].slice(1) + '{';
                let i = -1;
                while ((i = result.indexOf(pattern, i + 1)) > -1 && result.indexOf("}", i + 1) > i) {
                    const newString = result[i + mark[0].length + 2] + mark[1];
                    result = result.slice(0, i) + newString + result.slice(i + 1 + mark[0].length + 3);
                }
            }
            
            return result;
        }
        
        // Unicode font mappings (from unicode-formatter)
        const unicodeFonts = {
            normal: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~",
            sansBold: "\"\\ !#$%&'()*+,-./𝟬𝟭𝟮𝟯𝟰𝟱𝟲𝟳𝟴𝟵:;<=>?@𝗔𝗕𝗖𝗗𝗘𝗙𝗚𝗛𝗜𝗝𝗞𝗟𝗠𝗡𝗢𝗣𝗤𝗥𝗦𝗧𝗨𝗩𝗪𝗫𝗬𝗭[]^_`𝗮𝗯𝗰𝗱𝗲𝗳𝗴𝗵𝗶𝗷𝗸𝗹𝗺𝗻𝗼𝗽𝗾𝗿𝘀𝘁𝘂𝘃𝘄𝘅𝘆𝘇{|}~",
            sansItalic: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@𝘈𝘉𝘊𝘋𝘌𝘍𝘎𝘏𝘐𝘑𝘒𝘓𝘔𝘕𝘖𝘗𝘘𝘙𝘚𝘛𝘜𝘝𝘞𝘟𝘠𝘡[]^_`𝘢𝘣𝘤𝘥𝘦𝘧𝘨𝘩𝘪𝘫𝘬𝘭𝘮𝘯𝘰𝘱𝘲𝘳𝘴𝘵𝘶𝘷𝘸𝘹𝘺𝘻{|}~",
            sansBoldItalic: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@𝘼𝘽𝘾𝘿𝙀𝙁𝙂𝙃𝙄𝙅𝙆𝙇𝙈𝙉𝙊𝙋𝙌𝙍𝙎𝙏𝙐𝙑𝙒𝙓𝙔𝙕[]^_`𝙖𝙗𝙘𝙙𝙚𝙛𝙜𝙝𝙞𝙟𝙠𝙡𝙢𝙣𝙤𝙥𝙦𝙧𝙨𝙩𝙪𝙫𝙬𝙭𝙮𝙯{|}~",
            monospace: "\"\\ !#$%&'()*+,-./𝟶𝟷𝟸𝟹𝟺𝟻𝟼𝟽𝟾𝟿:;<=>?@𝙰𝙱𝙲𝙳𝙴𝙵𝙶𝙷𝙸𝙹𝙺𝙻𝙼𝙽𝙾𝙿𝚀𝚁𝚂𝚃𝚄𝚅𝚆𝚇𝚈𝚉[]^_`𝚊𝚋𝚌𝚍𝚎𝚏𝚐𝚑𝚒𝚓𝚔𝚕𝚖𝚗𝚘𝚙𝚚𝚛𝚜𝚝𝚞𝚟𝚠𝚡𝚢𝚣{|}~",
            sans: "\"\\ !#$%&'()*+,-./𝟢𝟣𝟤𝟥𝟦𝟧𝟨𝟩𝟪𝟫:;<=>?@𝖠𝖡𝖢𝖣𝖤𝖥𝖦𝖧𝖨𝖩𝖪𝖫𝖬𝖭𝖮𝖯𝖰𝖱𝖲𝖳𝖴𝖵𝖶𝖷𝖸𝖹[]^_`𝖺𝖻𝖼𝖽𝖾𝖿𝗀𝗁𝗂𝗃𝗄𝗅𝗆𝗇𝗈𝗉𝗊𝗋𝗌𝗍𝗎𝗏𝗐𝗑𝗒𝗓{|}~",
            fraktur: "\"\\ !#$%&'()*+,-./0123456789:;<=>?@𝔄𝔅ℭ𝔇𝔈𝔉𝔊ℌℑ𝔍𝔎𝔏𝔐𝔑𝔒𝔓𝔔ℜ𝔖𝔗𝔘𝔙𝔚𝔛𝔜ℨ[]^_`𝔞𝔟𝔠𝔡𝔢𝔣𝔤𝔥𝔦𝔧𝔨𝔩𝔪𝔫𝔬𝔭𝔮𝔯𝔰𝔱𝔲𝔳𝔴𝔵𝔶𝔷{|}~"
        };
        
        // Convert text using Unicode font mapping
        function convertToUnicodeFont(text, targetFont) {
            const normalChars = Array.from(unicodeFonts.normal);
            const targetChars = Array.from(unicodeFonts[targetFont]);
            
            return Array.from(text).map(char => {
                const index = normalChars.indexOf(char);
                return index !== -1 ? targetChars[index] : char;
            }).join('');
        }
        
        // Text formatting functions
        function applyTextFormatting(text) {
            // Handle nested bold+italic first
            text = text.replace(/\\textbf\{([^{}]*\\textit\{[^{}]*\}[^{}]*)\}/g, (match, content) => {
                return convertToUnicodeFont(content.replace(/\\textit\{([^{}]*)\}/g, '$1'), 'sansBoldItalic');
            });
            
            text = text.replace(/\\textit\{([^{}]*\\textbf\{[^{}]*\}[^{}]*)\}/g, (match, content) => {
                return convertToUnicodeFont(content.replace(/\\textbf\{([^{}]*)\}/g, '$1'), 'sansBoldItalic');
            });
            
            // Handle individual formatting
            text = text.replace(/\\textbf\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sansBold'));
            text = text.replace(/\\textit\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sansItalic'));
            text = text.replace(/\\emph\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sansItalic'));
            text = text.replace(/\\texttt\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'monospace'));
            text = text.replace(/\\mathrm\{([^{}]*)\}/g, (match, content) => convertToUnicodeFont(content, 'sans'));
            
            return text;
        }
        
        // Process math content with support for \mathfrak
        function processMathContent(mathContent) {
            // Handle \mathfrak first (before general replacements)
            mathContent = mathContent.replace(/\\mathfrak\{([^{}]*)\}/g, (match, content) => {
                return convertToUnicodeFont(content, 'fraktur');
            });
            
            // Apply general math replacements
            return replaceUnicode(mathContent);
        }
        
        // Main conversion function
        function convertLatexToUnicode(input) {
            let result = input;
            
            // Process math delimiters \( ... \) and $ ... $
            result = result.replace(/\\\(([^\\]*(?:\\.[^\\]*)*)\\\)/g, (match, mathContent) => {
                return processMathContent(mathContent);
            });
            
            result = result.replace(/\$([^$]+)\$/g, (match, mathContent) => {
                return processMathContent(mathContent);
            });
            
            // Process text formatting outside of math mode
            result = applyTextFormatting(result);
            
            return result;
        }
        
        // Smart breaking utilities
        function isInMathMode(text, position) {
            // Count math delimiters before position
            let dollarCount = 0;
            let parenCount = 0;
            
            for (let i = 0; i < position; i++) {
                if (text[i] === '$' && (i === 0 || text[i-1] !== '\\')) {
                    dollarCount++;
                } else if (i < position - 1 && text.substr(i, 2) === '\\(' && (i === 0 || text[i-1] !== '\\')) {
                    parenCount++;
                } else if (i < position - 1 && text.substr(i, 2) === '\\)' && (i === 0 || text[i-1] !== '\\')) {
                    parenCount--;
                }
            }
            
            return (dollarCount % 2 === 1) || (parenCount > 0);
        }
        
        function isInTextCommand(text, position) {
            // Look for unclosed text commands before position
            const textCommands = ['\\textbf{', '\\textit{', '\\emph{', '\\texttt{'];
            let openCommands = 0;
            
            for (let i = 0; i < position; i++) {
                for (const cmd of textCommands) {
                    if (text.substr(i, cmd.length) === cmd) {
                        openCommands++;
                        i += cmd.length - 1;
                        break;
                    }
                }
                if (text[i] === '}' && openCommands > 0) {
                    openCommands--;
                }
            }
            
            return openCommands > 0;
        }
        
        function shouldDelayBreaking(text) {
            const length = text.length;
            return isInMathMode(text, length) || isInTextCommand(text, length);
        }
        
        function findLastWordBoundary(text) {
            // Find the last word boundary, but don't break inside math expressions or text commands
            const wordBoundaryRegex = /[\s\-\u2013\u2014]/; // whitespace, hyphen, en-dash, em-dash
            
            for (let i = text.length - 1; i >= 0; i--) {
                if (wordBoundaryRegex.test(text[i])) {
                    // Check if this boundary is inside a math expression or text command
                    if (isInMathMode(text, i) || isInTextCommand(text, i)) {
                        // Skip this boundary - it's inside a protected region
                        continue;
                    }
                    // Found a valid boundary, return position after it (start of last word/expression)
                    return i + 1;
                }
            }
            
            // No word boundary found, return 0 (whole text is one word)
            return 0;
        }
        
        function performSmartBreaking(boxId, editor, newBox) {
            const input = editor.getValue();
            
            // Find the last word boundary
            const lastWordStart = findLastWordBoundary(input);
            
            // If no word boundary found or it's at the beginning, do character-based splitting
            if (lastWordStart === 0) {
                return;
            }
            
            // Split the text
            const firstPart = input.substring(0, lastWordStart);
            const secondPart = input.substring(lastWordStart);
            
            // Update the current box with the first part
            editor.setValue(firstPart);
            
            // Set the second part in the new box
            newBox.editor.setValue(secondPart);
            
            // Position cursor at the end of the moved text in the new box
            newBox.editor.setCursor(newBox.editor.lineCount(), 0);
        }

        // Get enumeration string for a thread box
        function getEnumerationString(boxId) {
            const enumerationType = document.getElementById('enumerate').value;
            if (enumerationType === 'none') {
                return '';
            }
            
            const boxIndex = threadBoxes.findIndex(box => box.id === boxId);
            const currentNumber = boxIndex + 1;
            
            if (enumerationType === 'n') {
                return ` [${currentNumber}/n]`;
            } else if (enumerationType === 'total') {
                const totalBoxes = threadBoxes.length;
                return ` [${currentNumber}/${totalBoxes}]`;
            }
            
            return '';
        }

        // Thread box management
        function createThreadBox(insertAfter = null) {
            const boxId = nextBoxId++;
            const platform = document.getElementById('platform').value;
            const limit = PLATFORM_LIMITS[platform];
            
            const boxElement = document.createElement('div');
            boxElement.className = 'thread-box';
            boxElement.dataset.boxId = boxId;
            
            const isFirst = threadBoxes.length === 0;
            
            boxElement.innerHTML = `
                <div class="box-header">
                    <div class="box-number">Tweet <span class="box-count">1</span>/<span class="total-count">1</span></div>
                    <div class="box-controls">
                        ${!isFirst ? `<button class="delete-box" onclick="showDeleteModal(${boxId})">×</button>` : ''}
                    </div>
                </div>
                <div class="editor-section">
                    <div class="latex-input">
                        <label>LaTeX Input:</label>
                        <textarea id="latex-${boxId}"></textarea>
                    </div>
                    <div class="unicode-output">
                        <div class="output-header">
                            <label>Unicode Output:</label>
                            <button class="copy-btn" onclick="copyToClipboard(${boxId})" title="Copy to clipboard">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                    <path d="m5 15v-11a2 2 0 0 1 2 -2h11"></path>
                                </svg>
                            </button>
                        </div>
                        <div class="output-box" id="output-${boxId}"></div>
                        <div class="char-counter" id="counter-${boxId}">0</div>
                    </div>
                </div>
            `;
            
            // Insert box in the right position in the array first (before CodeMirror initialization)
            const tempBoxInfo = {
                id: boxId,
                element: boxElement,
                editor: null, // Will be set after CodeMirror is initialized
                limit: limit
            };
            
            if (insertAfter === null) {
                threadBoxes.push(tempBoxInfo);
                
                // If this is the first box, add it directly to the DOM
                if (threadBoxes.length === 1) {
                    const container = document.getElementById('threadContainer');
                    container.appendChild(boxElement);
                    
                    // Add final separator with + button
                    const finalSeparator = document.createElement('div');
                    finalSeparator.className = 'final-separator';
                    finalSeparator.innerHTML = '<button class="add-box-btn" onclick="createThreadBox()">+</button>';
                    container.appendChild(finalSeparator);
                    
                    updateBoxNumbers();
                } else {
                    // Rebuild DOM for subsequent boxes
                    rebuildThreadDOM();
                }
            } else {
                const insertIndex = threadBoxes.findIndex(box => box.id === insertAfter) + 1;
                threadBoxes.splice(insertIndex, 0, tempBoxInfo);
                
                // Rebuild the entire DOM structure to ensure correct ordering
                rebuildThreadDOM();
            }
            
            // Now initialize CodeMirror after the element is in the DOM
            const textarea = document.getElementById(`latex-${boxId}`);
            const editor = CodeMirror.fromTextArea(textarea, {
                mode: 'stex',
                theme: 'default',
                lineNumbers: false,
                lineWrapping: true,
                placeholder: 'Enter LaTeX here...'
            });
            
            // Set up event handlers
            editor.on('change', () => handleInputChange(boxId, editor));
            
            // Update the box info with the editor
            const boxInfo = threadBoxes.find(box => box.id === boxId);
            boxInfo.editor = editor;
            
            // Focus the new editor
            editor.focus();
            
            return boxInfo;
        }
        
        function rebuildThreadDOM() {
            const container = document.getElementById('threadContainer');
            container.innerHTML = '';
            
            threadBoxes.forEach((box, index) => {
                // Update delete button visibility (first box should not have delete button)
                const deleteBtn = box.element.querySelector('.delete-box');
                if (index === 0) {
                    if (deleteBtn) deleteBtn.remove();
                } else {
                    if (!deleteBtn) {
                        const boxControls = box.element.querySelector('.box-controls');
                        const newDeleteBtn = document.createElement('button');
                        newDeleteBtn.className = 'delete-box';
                        newDeleteBtn.onclick = () => showDeleteModal(box.id);
                        newDeleteBtn.textContent = '×';
                        boxControls.appendChild(newDeleteBtn);
                    }
                }
                
                // Add the box
                container.appendChild(box.element);
                
                // Add separator with + button (except after the last box)
                if (index < threadBoxes.length - 1) {
                    const separator = document.createElement('div');
                    separator.className = 'thread-separator';
                    separator.innerHTML = `<button class="add-box-btn" onclick="createThreadBox(${box.id})">+</button>`;
                    container.appendChild(separator);
                }
            });
            
            // Add final separator with + button after the last box
            const finalSeparator = document.createElement('div');
            finalSeparator.className = 'final-separator';
            finalSeparator.innerHTML = '<button class="add-box-btn" onclick="createThreadBox()">+</button>';
            container.appendChild(finalSeparator);
            
            updateBoxNumbers();
        }
        
        function handleInputChange(boxId, editor) {
            const input = editor.getValue();
            const baseOutput = convertLatexToUnicode(input);
            const enumeration = getEnumerationString(boxId);
            const output = baseOutput + enumeration;
            const outputElement = document.getElementById(`output-${boxId}`);
            const counterElement = document.getElementById(`counter-${boxId}`);
            
            outputElement.textContent = output;
            
            const box = threadBoxes.find(b => b.id === boxId);
            const platform = document.getElementById('platform').value;
            const charCount = getAccurateCharacterCount(output, platform);
            const limit = box.limit;
            
            counterElement.textContent = `${charCount}`;
            
            // Update counter styling based on usage
            counterElement.className = 'char-counter';
            if (charCount >= limit) {
                counterElement.className += ' over-limit';
            } else if (charCount >= limit * 0.9) {
                counterElement.className += ' near-limit';
            }
            
            // Auto-create new box if we hit the limit AND we're in the final box
            const isLastBox = boxId === threadBoxes[threadBoxes.length - 1].id;
            
            if (charCount > limit && isLastBox) {
                const input = editor.getValue();
                
                // Delay breaking if we're in math mode or unclosed text command
                if (shouldDelayBreaking(input)) {
                    // Don't create new box yet - wait until math/command is closed
                    return;
                }
                
                const newBox = createThreadBox();
                
                // Apply smart breaking if enabled (we already know we exceed the limit)
                const smartBreakingEnabled = document.getElementById('smartBreaking').checked;
                
                if (smartBreakingEnabled) {
                    performSmartBreaking(boxId, editor, newBox);
                } else {
                    // Default behavior: just focus the new box
                    setTimeout(() => newBox.editor.focus(), 100);
                }
            }
        }
        
        function updateBoxNumbers() {
            const total = threadBoxes.length;
            threadBoxes.forEach((box, index) => {
                const boxCountElement = box.element.querySelector('.box-count');
                const totalCountElement = box.element.querySelector('.total-count');
                boxCountElement.textContent = index + 1;
                totalCountElement.textContent = total;
            });
            
            // Update all outputs since enumeration depends on box position and total count
            updateAllEnumeratedOutputs();
        }
        
        function updateAllEnumeratedOutputs() {
            threadBoxes.forEach(box => {
                if (box.editor) {
                    handleInputChange(box.id, box.editor);
                }
            });
        }
        
        function updateAllLimits() {
            const platform = document.getElementById('platform').value;
            const limit = PLATFORM_LIMITS[platform];
            
            threadBoxes.forEach(box => {
                box.limit = limit;
                const counterElement = document.getElementById(`counter-${box.id}`);
                const outputElement = document.getElementById(`output-${box.id}`);
                const charCount = getAccurateCharacterCount(outputElement.textContent, platform);
                
                counterElement.textContent = `${charCount}`;
                
                // Update counter styling based on usage
                counterElement.className = 'char-counter';
                if (charCount >= limit) {
                    counterElement.className += ' over-limit';
                } else if (charCount >= limit * 0.9) {
                    counterElement.className += ' near-limit';
                }
            });
        }
        
        function showDeleteModal(boxId) {
            deleteBoxId = boxId;
            document.getElementById('modalOverlay').style.display = 'block';
        }
        
        function closeModal() {
            deleteBoxId = null;
            document.getElementById('modalOverlay').style.display = 'none';
        }
        
        function confirmDelete() {
            if (deleteBoxId && threadBoxes.length > 1) {
                const boxIndex = threadBoxes.findIndex(box => box.id === deleteBoxId);
                if (boxIndex > -1) {
                    // Remove from array
                    threadBoxes.splice(boxIndex, 1);
                    
                    // Rebuild DOM
                    rebuildThreadDOM();
                    
                    // Focus previous box if available
                    if (boxIndex > 0) {
                        const prevBox = threadBoxes[boxIndex - 1];
                        prevBox.editor.focus();
                        prevBox.editor.setCursor(prevBox.editor.lineCount(), 0);
                    } else if (threadBoxes.length > 0) {
                        threadBoxes[0].editor.focus();
                    }
                }
            }
            closeModal();
        }
        
        function copyToClipboard(boxId) {
            const outputElement = document.getElementById(`output-${boxId}`);
            const text = outputElement.textContent;
            
            navigator.clipboard.writeText(text).then(() => {
                const copyBtn = document.querySelector(`[data-box-id="${boxId}"] .copy-btn`);
                const originalContent = copyBtn.innerHTML;
                const originalTitle = copyBtn.title;
                
                // Show success state
                copyBtn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20,6 9,17 4,12"></polyline>
                    </svg>
                `;
                copyBtn.title = 'Copied!';
                copyBtn.style.color = '#2ed573';
                copyBtn.style.borderColor = '#2ed573';
                copyBtn.style.background = '#f0f9f4';
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalContent;
                    copyBtn.title = originalTitle;
                    copyBtn.style.color = '';
                    copyBtn.style.borderColor = '';
                    copyBtn.style.background = '';
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
                alert('Failed to copy to clipboard');
            });
        }
        
        // Dark mode functionality
        function initDarkMode() {
            const darkModeToggle = document.getElementById('darkMode');
            const body = document.body;
            
            // Check for saved preference or default to dark mode
            const savedTheme = localStorage.getItem('darkMode');
            const prefersDark = savedTheme !== null ? savedTheme === 'true' : true; // Default to dark
            
            // Apply initial theme
            darkModeToggle.checked = prefersDark;
            if (prefersDark) {
                body.classList.add('dark-mode');
            }
            
            // Toggle functionality
            darkModeToggle.addEventListener('change', function() {
                if (this.checked) {
                    body.classList.add('dark-mode');
                    localStorage.setItem('darkMode', 'true');
                } else {
                    body.classList.remove('dark-mode');
                    localStorage.setItem('darkMode', 'false');
                }
            });
        }
        
        // Event listeners
        document.getElementById('platform').addEventListener('change', updateAllLimits);
        document.getElementById('enumerate').addEventListener('change', updateAllEnumeratedOutputs);
        
        document.getElementById('modalOverlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                closeModal();
            }
        });
        
        // Initialize with first thread box and dark mode
        document.addEventListener('DOMContentLoaded', () => {
            initDarkMode();
            createThreadBox();
        });
    </script>
</body>
</html>
